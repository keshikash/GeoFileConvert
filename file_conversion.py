# -*- coding: utf-8 -*-
"""
/***************************************************************************
 FileConversion
                                 A QGIS plugin
 this plugin converts csv into kml and vice versa
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2025-06-25
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Keshika Sharma
        email                : b22ee040@iitj.ac.in
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, Qt,  QVariant
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import (
    QAction, QFileDialog, QMessageBox, QTableWidgetItem, QHeaderView, QAbstractItemView
)

from .resources import *
from .file_conversion_dialog import FileConversionDialog

import os
import csv
import sys
sys.path.append(os.path.join(os.path.dirname(__file__), 'libs'))

from qgis.core import (
    QgsVectorLayer,
    QgsVectorFileWriter,
    QgsProject,
    QgsField,
    QgsFeature,
    QgsGeometry,
    QgsPointXY,
    QgsCoordinateReferenceSystem,
    QgsCoordinateTransform,
    QgsPalLayerSettings,
    QgsVectorLayerSimpleLabeling
)
from qgis.gui import QgsProjectionSelectionDialog
from natsort import natsorted


class FileConversion:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'FileConversion_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&File Conversion')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('FileConversion', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToVectorMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/file_conversion/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'File Conversion'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginVectorMenu(
                self.tr(u'&File Conversion'),
                action)
            self.iface.removeToolBarIcon(action)

    def run(self):
        """Run method that performs all the real work"""

        self.dlg = FileConversionDialog()

        # Always rebind the top-level radio toggles
        self.dlg.radio_csv_to_kml.toggled.connect(self.switch_to_page_2)
        self.dlg.radio_kml_to_csv.toggled.connect(self.switch_to_page_5)

        self.reset_dialog()
        self.dlg.show()

    #movement from one page to another in stacked wdiget based on the radio buttons
    def switch_to_page_2(self):
        if self.dlg.radio_csv_to_kml.isChecked():
            self.dlg.stackedWidget.setCurrentIndex(1)

            # Connect point and line radio buttons (only once)
            self.dlg.radiopoint.toggled.connect(self.switch_to_page_3)
            self.dlg.radioline.toggled.connect(self.switch_to_page_4)
            self.dlg.btnBack_3.clicked.connect(self.go_back)

    def switch_to_page_3(self):
        if self.dlg.radiopoint.isChecked():
            self.dlg.stackedWidget.setCurrentIndex(2)

            self.dlg.btnBrowseCSV.clicked.connect(self.browse_csv)
            self.dlg.btnSelectCRS.clicked.connect(self.select_crs)
            self.dlg.btnBrowseOutput.clicked.connect(self.browse_kml)
            self.dlg.btnConvert.clicked.connect(self.convert_csv_kml_point)
            self.dlg.btnCancel.clicked.connect(self.exit_conversion)
            self.dlg.btnBack.clicked.connect(self.go_back)

    def switch_to_page_4(self):
        if self.dlg.radioline.isChecked():
            self.dlg.stackedWidget.setCurrentIndex(3)

            self.dlg.btnBrowseCSV_2.clicked.connect(self.browse_csv)
            self.dlg.btnSelectCRS_2.clicked.connect(self.select_crs)
            self.dlg.btnConvert_2.clicked.connect(self.convert_csv_kml_line)
            self.dlg.btnBrowseOutput_2.clicked.connect(self.browse_kml)
            self.dlg.btnCancel_2.clicked.connect(self.exit_conversion)
            self.dlg.btnBack_2.clicked.connect(self.go_back)

    def switch_to_page_5(self):
        if self.dlg.radio_kml_to_csv.isChecked():
            self.dlg.stackedWidget.setCurrentIndex(4)
            self.dlg.btnBrowseKML.clicked.connect(self.browse_kml_input)
            self.dlg.btnBrowseOutput_3.clicked.connect(self.browse_output_folder_kml2csv)
            self.dlg.btnConvert_kml.clicked.connect(self.convert_kml_to_csv)
            self.dlg.btnBack_4.clicked.connect(self.go_back)
            self.dlg.btnCancel_3.clicked.connect(self.exit_conversion)

    def reset_dialog(self):
        """Reset the dialog to initial state"""
        #Uncheck all radio buttons
        self.dlg.radio_csv_to_kml.setAutoExclusive(False)
        self.dlg.radio_kml_to_csv.setAutoExclusive(False)
        self.dlg.radio_csv_to_kml.setChecked(False)
        self.dlg.radio_kml_to_csv.setChecked(False)
        self.dlg.radio_csv_to_kml.setAutoExclusive(True)
        self.dlg.radio_kml_to_csv.setAutoExclusive(True)

        #Reset geometry selection radio buttons if any (example: radio_point, radio_line)
        if hasattr(self.dlg, "radio_point"):
            self.dlg.radiopoint.setChecked(False)
        if hasattr(self.dlg, "radio_line"):
            self.dlg.radioline.setChecked(False)

        #Reset to the start page (assumed index 0)
        self.dlg.stackedWidget.setCurrentIndex(0)

    def browse_csv(self):
        print("Button clicked!")
        file_path, _ = QFileDialog.getOpenFileName(
            self.dlg,
            "Select CSV File",
            "",
            "CSV Files (*.csv);;All Files (*)"
        )

        if file_path:
            current_index = self.dlg.stackedWidget.currentIndex()

            if current_index == 2:
                self.dlg.lineEdit_csvPath.setText(file_path)
                self.dlg.lineEdit_outputPath.setText(os.path.dirname(file_path))
            elif current_index == 3:
                self.dlg.lineEdit_csvPath_2.setText(file_path)
                self.dlg.lineEdit_outputPath_2.setText(os.path.dirname(file_path))

            self.preview_csv(file_path)

    def preview_csv(self, file_path):
        with open(file_path, newline='', encoding='utf-8') as csvfile:
            reader = csv.DictReader(csvfile)
            headers = reader.fieldnames
            sample_rows = []
            try:
                for i, row in enumerate(reader):
                    sample_rows.append(row)
                    if i >= 9:
                        break
            except:
                pass

        numeric_columns = []
        for header in headers:
            try:
                if all(
                        row[header].strip() != "" and
                        row[header].replace(".", "", 1).replace("-", "", 1).isdigit()
                        for row in sample_rows
                ):
                    numeric_columns.append(header)
            except:
                continue

        current_index = self.dlg.stackedWidget.currentIndex()

        if current_index == 2:  #Page 3: Point CSV to KML
            self.dlg.comboLat.clear()
            self.dlg.comboLon.clear()
            self.dlg.comboLat.addItems([""] + numeric_columns)
            self.dlg.comboLon.addItems([""] + numeric_columns)

        elif current_index == 3:  #Page 4: Line CSV to KML
            self.dlg.comboLineID.clear()
            self.dlg.combo_start_lon.clear()
            self.dlg.combo_start_lat.clear()
            self.dlg.combo_end_lon.clear()
            self.dlg.combo_end_lat.clear()

            # Only include columns with no blank values in the sample
            non_blank_columns = []
            for header in headers:
                try:
                    if all(row[header].strip() != "" for row in sample_rows):
                        non_blank_columns.append(header)
                except:
                    continue

            self.dlg.comboLineID.addItems([""] + non_blank_columns)

            self.dlg.combo_start_lon.addItems([""] + numeric_columns)
            self.dlg.combo_start_lat.addItems([""] + numeric_columns)
            self.dlg.combo_end_lon.addItems([""] + numeric_columns)
            self.dlg.combo_end_lat.addItems([""] + numeric_columns)

        self.sample_rows = sample_rows  #For preview table

        #Preview table shared setup
        self.dlg.tablePreview.setFocusPolicy(Qt.NoFocus)
        self.dlg.tablePreview.setEditTriggers(QAbstractItemView.NoEditTriggers)
        self.dlg.tablePreview.setVerticalScrollMode(QAbstractItemView.ScrollPerPixel)
        self.dlg.tablePreview.setHorizontalScrollMode(QAbstractItemView.ScrollPerPixel)
        self.dlg.tablePreview.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)

        if current_index == 2:
            def update_preview_page3():
                lat_col = self.dlg.comboLat.currentText()
                lon_col = self.dlg.comboLon.currentText()

                self.dlg.tablePreview.setColumnCount(2)
                self.dlg.tablePreview.setHorizontalHeaderLabels([lon_col, lat_col])
                self.dlg.tablePreview.setRowCount(min(5, len(self.sample_rows)))

                for i, row in enumerate(self.sample_rows[:5]):
                    self.dlg.tablePreview.setItem(i, 0, QTableWidgetItem(row.get(lon_col, "")))
                    self.dlg.tablePreview.setItem(i, 1, QTableWidgetItem(row.get(lat_col, "")))

                header = self.dlg.tablePreview.horizontalHeader()
                header.setStretchLastSection(False)
                header.setSectionResizeMode(0, QHeaderView.Stretch)
                header.setSectionResizeMode(1, QHeaderView.Stretch)

                self.dlg.tablePreview.resizeRowsToContents()
                row_height = self.dlg.tablePreview.rowHeight(0)
                header_height = self.dlg.tablePreview.horizontalHeader().height()
                total_height = row_height * min(5, self.dlg.tablePreview.rowCount()) + header_height + 4
                self.dlg.tablePreview.setMinimumHeight(total_height)
                self.dlg.tablePreview.setMaximumHeight(total_height)

            self.dlg.comboLat.currentIndexChanged.connect(update_preview_page3)
            self.dlg.comboLon.currentIndexChanged.connect(update_preview_page3)
            update_preview_page3()

        elif current_index == 3:
            def update_preview_page4():
                line_col = self.dlg.comboLineID.currentText()
                slon_col = self.dlg.combo_start_lon.currentText()
                slat_col = self.dlg.combo_start_lat.currentText()
                elon_col = self.dlg.combo_end_lon.currentText()
                elat_col = self.dlg.combo_end_lat.currentText()

                self.dlg.tablePreview_2.setColumnCount(5)
                self.dlg.tablePreview_2.setHorizontalHeaderLabels(
                    [line_col, slon_col, slat_col, elon_col, elat_col]
                )
                self.dlg.tablePreview_2.setRowCount(min(5, len(self.sample_rows)))

                for i, row in enumerate(self.sample_rows[:5]):
                    values = [
                        row.get(line_col, ""),
                        row.get(slon_col, ""),
                        row.get(slat_col, ""),
                        row.get(elon_col, ""),
                        row.get(elat_col, "")
                    ]
                    for j, val in enumerate(values):
                        self.dlg.tablePreview_2.setItem(i, j, QTableWidgetItem(val))

                header = self.dlg.tablePreview_2.horizontalHeader()
                for j in range(5):
                    header.setSectionResizeMode(j, QHeaderView.Stretch)

                self.dlg.tablePreview_2.resizeRowsToContents()
                row_height = self.dlg.tablePreview_2.rowHeight(0)
                header_height = self.dlg.tablePreview_2.horizontalHeader().height()
                total_height = row_height * min(5, self.dlg.tablePreview_2.rowCount()) + header_height + 4
                self.dlg.tablePreview_2.setMinimumHeight(total_height)
                self.dlg.tablePreview_2.setMaximumHeight(total_height)

            self.dlg.comboLineID.currentIndexChanged.connect(update_preview_page4)
            self.dlg.combo_start_lon.currentIndexChanged.connect(update_preview_page4)
            self.dlg.combo_start_lat.currentIndexChanged.connect(update_preview_page4)
            self.dlg.combo_end_lon.currentIndexChanged.connect(update_preview_page4)
            self.dlg.combo_end_lat.currentIndexChanged.connect(update_preview_page4)
            update_preview_page4()

    def select_crs(self):
        print("Select CRS!")
        #Open the CRS selection dialog
        dlg = QgsProjectionSelectionDialog(self.iface.mapCanvas())

        if dlg.exec_():
            crs = dlg.crs()  #QgsCoordinateReferenceSystem object
            self.selected_crs = crs
            crs_text = f"{crs.authid()} - {crs.description()}"

            current_index = self.dlg.stackedWidget.currentIndex()

            #Update the correct line edit based on current page
            if current_index == 2 and hasattr(self.dlg, "lineEdit_crs"):
                self.dlg.lineEdit_crs.setText(crs_text)
            elif current_index == 3 and hasattr(self.dlg, "lineEdit_crs_2"):
                self.dlg.lineEdit_crs_2.setText(crs_text)

        self.dlg.raise_()
        self.dlg.activateWindow()

    def browse_kml(self):
        print("Button clicked for Output file!")
        folder_path = QFileDialog.getExistingDirectory(
            self.dlg,
            "Select Folder to Save KML"
        )
        if folder_path:
            current_index = self.dlg.stackedWidget.currentIndex()

            if current_index == 2:
                self.dlg.lineEdit_outputPath.setText(folder_path)
            elif current_index == 3:
                self.dlg.lineEdit_outputPath_2.setText(folder_path)

    def convert_csv_kml_point(self):
        print("Point Conversion Started!")

        csv_file = self.dlg.lineEdit_csvPath.text()
        output_folder = self.dlg.lineEdit_outputPath.text()
        lat_col = self.dlg.comboLat.currentText()
        lon_col = self.dlg.comboLon.currentText()

        if lat_col.strip() == "" or lon_col.strip() == "":
            QMessageBox.warning(self.dlg, "Missing Columns",
                                "Please select both Latitude and Longitude columns from the dropdowns.")
            return

        if not csv_file or not os.path.isfile(csv_file):
            QMessageBox.warning(self.dlg, "Error", "Please select a valid CSV file.")
            return

        crs_text = self.dlg.lineEdit_crs.text().strip()
        if not hasattr(self, 'selected_crs') or crs_text == "":
            QMessageBox.warning(self.dlg, "Error", "Please select CRS.")
            return

        try:
            with open(csv_file, newline='', encoding='utf-8') as f:
                reader = csv.DictReader(f)
                rows = list(reader)

            base = os.path.splitext(os.path.basename(csv_file))[0]
            kml_path = os.path.join(output_folder, f"{base}.kml")

            #Set up CRS transformation
            source_crs = self.selected_crs
            dest_crs = QgsCoordinateReferenceSystem("EPSG:4326")  #KML uses WGS 84
            transformer = QgsCoordinateTransform(source_crs, dest_crs, QgsProject.instance())

            #Create temp memory layer for points
            mem_layer = QgsVectorLayer("Point?crs=EPSG:4326", f"{base}_Points", "memory")
            prov = mem_layer.dataProvider()

            prov.addAttributes([QgsField(col, QVariant.String) for col in rows[0].keys()])
            mem_layer.updateFields()

            #Open and write KML
            with open(kml_path, 'w', encoding='utf-8') as kml_file:
                kml_file.write('<?xml version="1.0" encoding="UTF-8"?>\n')
                kml_file.write('<kml xmlns="http://www.opengis.net/kml/2.2">\n')
                kml_file.write('  <Document>\n')
                kml_file.write(f'    <name>{base}</name>\n')

                for row in rows:
                    try:
                        x = float(row[lon_col])
                        y = float(row[lat_col])
                        point = QgsPointXY(x, y)
                        transformed_point = transformer.transform(point)
                        lon = transformed_point.x()
                        lat = transformed_point.y()
                    except Exception:
                        continue  

                    #QGIS memory layer
                    feat = QgsFeature()
                    feat.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(lon, lat)))
                    feat.setAttributes([str(row.get(col, "")) for col in rows[0].keys()])
                    prov.addFeatures([feat])

                    name = row.get('name') or f"{lat},{lon}"
                    kml_file.write('    <Placemark>\n')
                    kml_file.write(f'      <name>{name}</name>\n')
                    kml_file.write('      <description><![CDATA[\n')
                    kml_file.write('        <table border="1" cellpadding="3" cellspacing="0">\n')
                    for key, value in row.items():
                        if key not in [lat_col, lon_col]:
                            kml_file.write(f'          <tr><th>{key}</th><td>{value}</td></tr>\n')
                    kml_file.write('        </table>\n')
                    kml_file.write('      ]]></description>\n')
                    kml_file.write('      <Point>\n')
                    kml_file.write(f'        <coordinates>{lon},{lat},0</coordinates>\n')
                    kml_file.write('      </Point>\n')
                    kml_file.write('    </Placemark>\n')

                kml_file.write('  </Document>\n')
                kml_file.write('</kml>\n')

            #Add layer to QGIS
            mem_layer.updateExtents()
            QgsProject.instance().addMapLayer(mem_layer)
            self.zoom_to_layer(mem_layer)

            QMessageBox.information(self.dlg, "Success", f"KML file saved at:\n{kml_path}")
            self.exit_conversion()

        except Exception as e:
            QMessageBox.critical(self.dlg, "Error", f"Failed to convert CSV to KML.\n\n{str(e)}")

    def convert_csv_kml_line(self):
        print("Line Conversion Started!")

        #Retrieve input paths and selections
        csv_file = self.dlg.lineEdit_csvPath_2.text()
        output_folder = self.dlg.lineEdit_outputPath_2.text()
        line_id_col = self.dlg.comboLineID.currentText()
        start_lon_col = self.dlg.combo_start_lon.currentText()
        start_lat_col = self.dlg.combo_start_lat.currentText()
        end_lon_col = self.dlg.combo_end_lon.currentText()
        end_lat_col = self.dlg.combo_end_lat.currentText()

        if any(col.strip() == "" for col in [line_id_col, start_lon_col, start_lat_col, end_lon_col, end_lat_col]):
            QMessageBox.warning(self.dlg, "Missing Columns", "Please select all required columns from the dropdowns.")
            return

        if not csv_file or not os.path.isfile(csv_file):
            QMessageBox.warning(self.dlg, "Error", "Please select a valid CSV file.")
            return

        crs_text = self.dlg.lineEdit_crs_2.text().strip()
        if not hasattr(self, 'selected_crs') or crs_text == "":
            QMessageBox.warning(self.dlg, "Error", "Please select CRS.")
            return

        #Read CSV and collect line segments grouped by line_id
        lines_dict = {}
        try:
            with open(csv_file, newline='', encoding='utf-8') as csvfile:
                reader = csv.DictReader(csvfile)
                reader.fieldnames = [f.strip() for f in reader.fieldnames]

                for row in reader:
                    try:
                        line_id = row[line_id_col].strip()
                        start_lon = float(row[start_lon_col])
                        start_lat = float(row[start_lat_col])
                        end_lon = float(row[end_lon_col])
                        end_lat = float(row[end_lat_col])

                        start_point = QgsPointXY(start_lon, start_lat)
                        end_point = QgsPointXY(end_lon, end_lat)

                        geom = QgsGeometry.fromPolylineXY([start_point, end_point])

                        lines_dict.setdefault(line_id, []).append(geom)
                    except Exception as e:
                        print("Skipping row due to error:", e)
                        continue
        except Exception as e:
            QMessageBox.critical(self.dlg, "Error", f"Error reading CSV file: {e}")
            return

        #Transform to WGS84
        source_crs = self.selected_crs
        dest_crs = QgsCoordinateReferenceSystem("EPSG:4326")
        transform = QgsCoordinateTransform(source_crs, dest_crs, QgsProject.instance())

        #Create temporary memory layer
        base_name = os.path.splitext(os.path.basename(csv_file))[0]
        layer = QgsVectorLayer("LineString?crs=EPSG:4326", f"{base_name}_MergedLines", "memory")
        pr = layer.dataProvider()
        pr.addAttributes([QgsField("line_id", QVariant.String)])
        layer.updateFields()

        #Merge segments per line_id
        for line_id, geoms in lines_dict.items():
            #transform each geometry's vertices
            transformed_geoms = []
            for g in geoms:
                coords = g.asPolyline()
                transformed_pts = [transform.transform(pt) for pt in coords]
                transformed_geom = QgsGeometry.fromPolylineXY(transformed_pts)
                transformed_geoms.append(transformed_geom)

            #Unary union and merge
            union_geom = QgsGeometry.unaryUnion(transformed_geoms)
            merged = union_geom.mergeLines()

            feat = QgsFeature()
            feat.setGeometry(merged)
            feat.setAttributes([line_id])
            pr.addFeature(feat)

        #Add layer to QGIS
        QgsProject.instance().addMapLayer(layer)
        self.zoom_to_layer(layer)
        self.enable_layer_labels(layer)

        kml_path = os.path.join(output_folder, f"{base_name}_lines.kml")

        try:
            result = QgsVectorFileWriter.writeAsVectorFormat(
                layer,
                kml_path,
                "utf-8",
                driverName="KML"
            )

            if isinstance(result, tuple):
                error_code, error_message = result
            else:
                error_code = result
                error_message = ""

            if error_code == QgsVectorFileWriter.NoError:
                QMessageBox.information(self.dlg, "Success", f"KML file saved at:\n{kml_path}")
                self.exit_conversion()
            else:
                QMessageBox.critical(
                    self.dlg,
                    "Error",
                    f"Failed to write KML file.\nError code: {error_code}\nError message: {error_message}"
                )

        except Exception as e:
            import traceback
            traceback.print_exc()
            QMessageBox.critical(self.dlg, "Error", f"Failed to write KML file.\n\n{str(e)}")

    def zoom_to_layer(self, layer):
        """
        Zooms the QGIS canvas to the extent of the given layer.
        """
        if not layer:
            return
        extent = layer.extent()
        self.iface.mapCanvas().setExtent(extent)
        self.iface.mapCanvas().refresh()

    def enable_layer_labels(self, layer):
        settings = QgsPalLayerSettings()
        settings.fieldName = "line_id"
        settings.placement = QgsPalLayerSettings.Line
        settings.enabled = True

        labeling = QgsVectorLayerSimpleLabeling(settings)
        layer.setLabelsEnabled(True)
        layer.setLabeling(labeling)
        layer.triggerRepaint()

    def browse_kml_input(self):
        print("Button clicked: Select KML file!")
        file_path, _ = QFileDialog.getOpenFileName(
            self.dlg,
            "Select KML File",
            "",
            "KML Files (*.kml);;All Files (*)"
        )

        if file_path:
            self.dlg.lineEdit_kmlPath.setText(file_path)
         
            self.dlg.lineEdit_output.setText(os.path.dirname(file_path))

    def browse_output_folder_kml2csv(self):
        print("Button clicked: Select output folder!")
        folder_path = QFileDialog.getExistingDirectory(
            self.dlg,
            "Select Folder to Save CSV"
        )
        if folder_path:
            self.dlg.lineEdit_output.setText(folder_path)

    def convert_kml_to_csv(self):
        print("KML to CSV Conversion Started!")

        kml_file = self.dlg.lineEdit_kmlPath.text().strip()
        output_file = self.dlg.lineEdit_output.text().strip()

        if not kml_file or not os.path.isfile(kml_file):
            QMessageBox.warning(self.dlg, "Error", "Please select a valid KML file.")
            return

        if not output_file:
            QMessageBox.warning(self.dlg, "Error", "Please specify an output CSV file.")
            return

        #Load KML as layer
        layer = QgsVectorLayer(kml_file, "KML_Layer", "ogr")
        if not layer.isValid():
            QMessageBox.critical(self.dlg, "Error", "Failed to load KML file.")
            return

        try:
            with open(output_file, "w", newline="", encoding="utf-8") as csvfile:
                writer = csv.writer(csvfile)

                headers = ["latitude", "longitude"] + [field.name() for field in layer.fields()]
                writer.writerow(headers)

                for feat in layer.getFeatures():
                    geom = feat.geometry()

                    if geom.isEmpty():
                        continue

                    if geom.type() == QgsWkbTypes.PointGeometry:
                        point = geom.asPoint()
                        lat = point.y()
                        lon = point.x()
                    else:
                        #skip non-points
                        continue

                    attrs = [str(val) for val in feat.attributes()]
                    writer.writerow([lat, lon] + attrs)

            QMessageBox.information(
                self.dlg, "Success", f"CSV file saved at:\n{output_file}"
            )

        except Exception as e:
            QMessageBox.critical(self.dlg, "Error", f"Failed to export CSV.\n\n{str(e)}")

    def go_back(self):
        current_index = self.dlg.stackedWidget.currentIndex()

        if current_index in (2, 3):
            #Coming from point or line CSV to KML -> back to geometry selection
            self.dlg.stackedWidget.setCurrentIndex(1)

            #Uncheck geometry selection radios
            for radio in [self.dlg.radiopoint, self.dlg.radioline]:
                radio.setAutoExclusive(False)
                radio.setChecked(False)
                radio.setAutoExclusive(True)

        elif current_index == 4:
            #Coming from KML to CSV -> back to main
            self.dlg.stackedWidget.setCurrentIndex(0)

            #Uncheck main page radios
            for radio in [self.dlg.radio_csv_to_kml, self.dlg.radio_kml_to_csv]:
                radio.setAutoExclusive(False)
                radio.setChecked(False)
                radio.setAutoExclusive(True)

        elif current_index == 1:
            #Coming from geometry selection -> back to main
            self.dlg.stackedWidget.setCurrentIndex(0)

            #Uncheck main page radios
            for radio in [self.dlg.radio_csv_to_kml, self.dlg.radio_kml_to_csv]:
                radio.setAutoExclusive(False)
                radio.setChecked(False)
                radio.setAutoExclusive(True)

        #Keep Back button visible
        self.dlg.btnBack.setVisible(True)

    def exit_conversion(self):
        print("Closed!")
        self.dlg.hide()